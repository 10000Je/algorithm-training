# no. 10775: 공항 (Gold II)
# G개의 게이트가 존재하며 각각 1부터 G까지의 번호를 가지고있다.
# i번째 비행기는 1부터 g[i]까지의 게이트중 하나에 도킹이 가능하다
# 비행기를 도킹할 수 없는 시점이 오면 중단하라
# 도킹시킬 수 있는 최대의 비행기 수를 출력하라

# 최대한 많은 비행기를 도킹시키기 위해서는, g[i]에 최대한 가깝게 도킹시켜야한다
# 처음에는 우선순위 큐를 이용해 접근하였으나, 계속되는 반례에 어떻게 해야하나 고민하였고
# 알고리즘 분류를 보니 분리집합을 이용하는 문제여서, 어떻게 분리집합을 이용할 수 
# 있는지 고민해보았다.

# i번째 비행기는 g[i]까지의 게이트에 도킹시킬 수 있다.
# "도킹 가능한 게이트"는 어떻게 정해질까? g[i]보다 작으면서도 최대한 큰
# "가용한" 게이트를 의미할 것이다. 그럼 우리는 g[i]들을 하나의 노드로 간주하고,
# g[i]의 루트노드를 도킹 가능한 게이트라고 정의해보자
# 1, 2, 3, 4 ... G 까지의 게이트가 존재하고, 아직 비행기가 하나도 도착하지 않았다면
# 각 노드는, 노드가 1개이고 루트노드가 본인인 분리집합으로 정의된다
# 이때 한 비행기를 도킹시켜야 한다고 해보자

# g[i]의 루트노드가 도킹 가능한 게이트이다. 이는 find(g[i]) 알고리즘을 통해
# 찾을 수 있다. 해당 루트노드를 r 이라고 해보자
# r을 사용했으면, r의 루트노드는 r-1의 루트노드와 같아져야한다.
# 따라서, union(r, r-1)을 통해, 두 집합을 합쳐줘야한다.

# 체감 난이도: Gold I
# 코드구현 존나 쉽지만, 아이디어 발상 개어렵다
# 이정도 아이디어면 골드1은 받아야한다고 소신발언한다

from sys import stdin
input = stdin.readline

g = int(input())
p = int(input())

parent = [i for i in range(g+1)]

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(a, b):
    root_a = find(a)
    root_b = find(b)
    parent[root_a] = root_b

cnt = 0
for _ in range(p):
    gi = int(input())
    root_gi = find(gi)
    if root_gi == 0:
        break
    union(root_gi, root_gi-1)
    cnt += 1
print(cnt)