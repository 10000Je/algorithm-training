# no.9527: 1의 개수 세기 (Gold II)
# A~B사이의 자연수를 2진수로 표현했을 때, 1의 개수의 합을 구하라
# 어떤 한 숫자 k를 2진수로 표현해보자
# k가 12이면 이는 1100 이다
# 마지막 자리부터 역순으로 탐색해서 1을 찾을떄까지 탐색한다
# 1"1"00 -> 이보다 작은 숫자들의 1의 개수를 카운트 해야한다
# 1 0 O O -> 이경우, O의 조합에 의해 이 숫자는 11~8까지의 숫자를 가질 수 있다
# 이때 O가 2개이므로, 1의 개수가 0인경우는 2C0*(1), 1인경우는 2C1*(2), 2인경우는
# 2C2*(3) -> 다 합해서 8이고, 실제로 8~11까지의 2진수 1의 개수의 합이 8인것을 확인할 수 있다
# 이제 다음 1을 찾을때까지 다시 탐색한다
# 0 O O O -> 이경우, O의 조합에 의해 이 숫자는 0부터 7까지의 숫자를 가질 수 있다
# 0인경우는 3C0*(0), 1인경우는 3C1*(1), 2인경우는 3C2*(2), 3인경우는 3C3*(3)
# 다 합해서 12이고, 실제로 0부터 7까지의 1의 개수의 합은 12임을 확인할 수 있다
# 이제 12와 8을 더하면 0부터 11까지의 2진수의 개수의 합이되고, 여기서 12를 2진수로 바꾼
# 1의 개수를 더해주면 22가되고, 이것이 1부터 12까지의 2진수 1의 개수의 합이다

# A,B가 주어졌을때 A-1까지의 1의 개수의 합, B까지의 1의 개수의 합을 각각 구한다음에
# 나중값에서 처음값을 뺴주면 답이 될것이다

# 체감 난이도: Gold II
# 조합론을 통해 접근하였지만, 누적합 접근방식으로도 풀 수 있긴하다
# 결국에는 동일한 부분이 어느정도 반복되기 때문이다.

a, b = map(int, input().split())

def fact(x):
    if x == 0:
        return 1
    return x*fact(x-1)

def comb(a, b):
    return fact(a)//(fact(b)*fact(a-b))

def count(x):
    _bin = list(map(int, bin(x)[2:]))
    cnt = _bin.count(1)
    for i in reversed(range(len(_bin))):
        if _bin[i] == 0:
            continue
        _bin[i] = 0
        n = _bin.count(1)
        for j in range(len(_bin)-i):
            cnt += comb(len(_bin)-i-1, j)*(n+j)
    return cnt

print(count(b)-count(a-1))